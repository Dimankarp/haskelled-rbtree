# Функциональное программирование - ЛР 1

## Введение

- Студент: ***Хороших Дмитрий Максимович 367597***
- Вариант: ***12, 19***

## Задачи

### Prob. 12
>
> The sequence of triangle numbers is generated by adding the natural numbers.
>
> What is the value of the first triangle number to have over five hundred divisors?  

 Фактически необходимо посчитать число делителей для каждого треугольного числа и выбрать первое, с подходящим число этих самых делителей

#### Prob. 12 - Решения

1. Модульное решение (*бесконечная последовательность, свёртка, отображение*)

```haskell

-- Sequence generation

triangularSeqInf :: (Integral a) => [a]
triangularSeqInf = 1 : [x + y | (x, y) <- zip triangularSeqInf [2 ..]]

...

-- Divisors counting

countDivisorsFold :: Int -> Int
countDivisorsFold x =
  (\c -> if rem x sqrtx == 0 then c + 1 else c) $
    (* 2) $
      foldr (\el acc -> if rem x el == 0 then acc + 1 else acc) 0 [1 .. sqrtx - 1]
  where
    sqrtx = flooredIntSqrt x

-- Main function

modularHighlyDivisibleTriangNum :: Int -> Int
modularHighlyDivisibleTriangNum x =
  fst $
    head $
      dropWhile ((<= x) . snd) $
        map (\y -> (y, countDivisorsFold y)) triangularSeqInf

```

1. Рекурсивное решение (*рекурсивный подсчёт делителей, хвостовая рекурсия перебора*)

```haskell
countDivisorsRecursion :: Int -> Int
countDivisorsRecursion x = 2 * go x sqrtx - (if rem x sqrtx == 0 then 1 else 0)
  where
    sqrtx = flooredIntSqrt x
    go n divisor
      | divisor == 1 = 1
      | otherwise = (if rem n divisor == 0 then 1 else 0) + go n (divisor - 1) -- Losing tail of recursion

recursiveHighlyDivisibleTriangNum :: Int -> Int
recursiveHighlyDivisibleTriangNum x = go 1 2
  where
    go prev_triag next_ind = if countDivisorsRecursion new_triag > x then new_triag else go new_triag $ next_ind + 1
      where
        new_triag = prev_triag + next_ind
```

1. Решение с хвостовой рекурсией (*в обоих случаях хвостовая рекурсия, подсчёт делителей -фактически переписанный руками fold*)

```haskell
countDivisorsTailRecursion :: Int -> Int
countDivisorsTailRecursion x = 2 * go x sqrtx 0 - (if rem x sqrtx == 0 then 1 else 0)
  where
    sqrtx = flooredIntSqrt x
    go n divisor accum
      | divisor == 1 = accum + 1
      | otherwise = go n (divisor - 1) (if rem n divisor == 0 then accum + 1 else accum)

tailRecursionHighlyDivisibleTriangNum :: Int -> Int
tailRecursionHighlyDivisibleTriangNum x = go 1 2
  where
    go prev_triag next_ind = if countDivisorsTailRecursion new_triag > x then new_triag else go new_triag $ next_ind + 1
      where
        new_triag = prev_triag + next_ind
```

### Prob. 19
>
> You are given the following information, but you may prefer to do some research for yourself.
>
>1 Jan 1900 was a Monday.
>
>Thirty days has September,
>
>April, June and November.
>
>All the rest have thirty-one,
>
>Saving February alone,
>
>Which has twenty-eight, rain or shine.
>
>And on leap years, twenty-nine.
>
>A leap year occurs on any year evenly divisible by 4, but not on a century >unless it is divisible by 400.
>
>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?

Если начать подсчёт с понедельника (%7 == 0) и прибавлять по размеру следующего месяца, то проверка на то, что день является воскресеньем представляет из себя сравнение (%7 == 6).

#### Prob. 19 - Решения

1. Рекурсивное решение (*рекурсивно бежим по годам, предрасчёт числа суббот для года*).

    Вычисляем массив weekDayToYearInfo, в котором по индексу, равному дню недели начала года получаем кортеж (день недели начала следующего года, число суббот в начале месяца). Далее рекурсией проходимся по каждому году и используем полученную структуру. Возможно, стоит переделать weekDayToYearInfo из функции в константу.

```haskell
weekDayToYearInfo :: Int -> [(Int, Int)]
-- Might be reasonable to create 2 constans (leap/ non-leap)
weekDayToYearInfo y = map (countSundays y) [0 .. 6]
  where
    countSundays year start =
      foldl'
        ( \(acc, count) el ->
            (rem (acc + monthToLen el year) 7, count + if acc == 6 then 1 else 0)
        )
        (start, 0)
        [1 .. 12]

recursiveCountSundays :: Int -> Int -> Int -> Int
recursiveCountSundays y1 stWk y2
  | y1 >= y2 = 0
  | otherwise = count + recursiveCountSundays (y1 + 1) endWk y2
  where
    (endWk, count) = weekDayToYearInfo y1 !! stWk
```

1. Bruteforce решение (*генерация дней в месяцe через list comprehension, foldl в основном методе*).

```haskell
monthDaysSeq :: Int -> Int -> [Int]
monthDaysSeq y1 y2 = [monthToLen y m | y <- [y1 .. y2], m <- [1 .. 12]]

bruteforceCountSundays :: Int -> Int -> Int
bruteforceCountSundays y1 y2 =
  snd
    $ foldl'
      (\(acc, count) el -> (rem (acc + el) 7, count + if acc == 6 then 1 else 0))
      (stWk, 0)
    $ monthDaysSeq
      y1
      y2
  where
    Date days = toDate y1 1 1
    stWk = rem days 7
```

## Вывод

1. Обе задачи требовали генерацию и обработку массива данных, так что list comprehension, fold и map сильно облегчили работу своей ориентацией на обработку последовательностей элементов.

2. Последовательность треугольных чисел удалось задать бесконечным листом.

3. При работе с рекурсией, заменяющей циклы, активно использовались guard'ы для выделения базового случая (конца рекурсии). Pattern matching использовался реже, потому что рекурсии в основном писались при помощи локальных функций go.

4. В целом активная фиксация на функциях и их композициях позволили задать правила обработки более *плотным* синтаксисом.

5. Основным преимуществом классического языка оказалось большая предсказуемость и доступность оптимизации.
